"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Maintainer: Jose Elera Campana <jelera at gmail.com>
"             http://www.twitter.com/jelera
"
" Version: 1.0 - 18/01/11 18:21:33
"
" Based_on:
"       http://amix.dk/blog/post/19486#The-ultimate-vim-configuration-vimrc
"
" How_to_Install_in_Unix_or_OSX:
"    $ ln -s $HOME/dotfiles/vim $HOME/.vim
"    $ ln -s $HOME/dotfiles/vim/vimrc $HOME/.vimrc
"
" Git_Repository_in_Github:
"    https://github.com/jelera/dotfiles
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => General
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" We want Vim to expand its full capability
set nocompatible

" Pathogen plugin management
silent! call pathogen#runtime_append_all_bundles()

" Display the mode you're in
set showmode

" Sets how many lines of history VIM has to remember
set history=500

" Automatical code indent
set autoindent
set cindent
set smartindent

"Show 3 lines of context around the cursor
set scrolloff=3

" Enable filetype plugin
filetype plugin on
filetype indent on

" Set to auto read when a file is changed from the outside
set autoread

" Automatically use the current file's directory as the working directory
set autochdir

" Enable code folding
set foldenable

" Hide Mouse when typing
set mousehide

" With a map leader it's possible to do extra key combinations
" like <leader>w saves the current file
let mapleader = ","
let g:mapleader = ","

" Fast saving
nmap <leader>w :w!<cr>

" Fast editing of the .vimrc
map <leader>vim :e $MYVIMRC<cr>

" Fast editing of the nazca colorscheme
map <leader>naz :e $HOME/.vim/colors/nazca.vim<cr>

" When vimrc is edited, reload it
autocmd bufwritepost .vimrc source $MYVIMRC

" Big Viminfo file
set viminfo='1000,f1,:1000,/1000

" Saving on losing focus (after tabbing away or switching buffers)
au FocusLost * :wa

" Open in last edit place
au BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$") | exe "normal g'\"" | endif

" Swap directory to store temporary files
set directory=$HOME/.vim/swapfiles,/var/tmp,/tmp,.

" Toggle between 'Relative' and 'Absolute' line numbers
map <leader>nn :call g:ToggleNuMode()<cr>
function! g:ToggleNuMode()
	if(&rnu == 1)
		set nu
	else
		set rnu
	endif
endfunc

if v:version >= 703
	" undo - set up persistent undo
	set undofile
	set undodir=$HOME/.undo
endif

set undolevels=999
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => VIM user interface
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set number
set showcmd " show typed commands
set wildmenu "Turn on WiLd menu
set wildmode=list:longest " activate TAB auto-completion for file paths

set ruler "Always show current position

set cmdheight=2 "The commandbar height

set hidden "Change buffer - without saving

set backspace=indent,eol,start " Set backspace config
set whichwrap+=<,>,h,l

set title " Set the Terminal Title

set ignorecase "Ignore case when searching
set smartcase   " but case-sensitive if expression contains a capital letter.

set hlsearch "Highlight search things

set incsearch "Make search act like search in modern browsers

set magic "Set magic on, for regular expressions

" Turn off the highlighted search
nnoremap <leader><space> :noh<cr>

set showmatch "Show matching bracets when text indicator is over them
set mat=2 "How many tenths of a second to blink

set lazyredraw " Don't redraw screen during macros

set ttyfast " Improves redrawing for newer computers

set noerrorbells " No sound on errors
set visualbell
set t_vb=

" Shortcut to rapidly toggle `set list`
nmap <leader>l :set list!<CR>

" Use the same symbols as TextMate for tabstops and EOLs
set listchars=tab:▸\ ,eol:¬

set tags+=../tags,../../tags,../../../tags,../../../../tags " Look for all the tags files in the recurrent directories

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Colors and Fonts
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
syntax enable "Enable syntax hl

set shell=$SHELL
set cursorline

if has("gui_running")
	set guioptions-=T
	set t_Co=256
	set background=dark
	colorscheme nazca
	set linespace=3
	" GUI is running or is about to start.
	" Maximize gvim window.
	set lines=50
	set columns=150
	if has("mac")
		set gfn=DejaVu\ Sans\ Mono\:h14
	else
		set gfn=DejaVu\ Sans\ Mono\ 9
	endif
else
	" This is console Vim.
	set background=dark
	set t_Co=256
	colorscheme nazca
	if exists("+lines")
		set lines=40
	endif
	if exists("+columns")
		set columns=125
	endif

endif

set encoding=utf8
try
	lang en_US
catch
endtry

set fileformats=unix "Default file types

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Files and backups
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Turn backup off, since most stuff is in SVN, git anyway...
set nobackup
set nowritebackup
set noswapfile

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Text, tab and indent related
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set shiftwidth=4
set tabstop=4
set smarttab

set linebreak " This will not break whole words while wrap is enabled
"set textwidth=79

set wrap "Wrap lines

set formatprg=par
" "set formatoptions=qr
" set colorcolumn=85 " This is that big red line at the right

set foldcolumn=3 " Fold column width

set showbreak=…

" Emulates Textmate's Ctrl-Q. Re-hardwraps paragraphs of text
nnoremap <leader>q gqip

" Mark tabs not used for indentation in Code
match errorMsg /[^\t]\zs\t\+/

map <leader>t2 :setlocal shiftwidth=2<cr>
map <leader>t4 :setlocal shiftwidth=4<cr>
map <leader>t8 :setlocal shiftwidth=4<cr>

" In MacOS X, Move around through wrapped lines
vmap <D-j> gj
vmap <D-k> gk
vmap <D-4> g$
vmap <D-6> g^
vmap <D-0> g^
nmap <D-j> gj
nmap <D-k> gk
nmap <D-4> g$
nmap <D-6> g^
nmap <D-0> g^

" Auto complete {} indent and position the cursor in the middle line
inoremap {      {}<Left>
inoremap {<CR>  {<CR>}<Esc>O
inoremap {{     {
inoremap {}     {}

inoremap (      ()<Left>
inoremap (<CR>  (<CR>)<Esc>O
inoremap ((     (
inoremap ()     ()

inoremap [      []<Left>
inoremap [<CR>  [<CR>]<Esc>O
inoremap [[     [
inoremap []     []

""""""""""""""""""""""""""
"  Code Comment Banners  "
""""""""""""""""""""""""""
autocmd FileType vim map <leader>comm I"<DEL>  <ESC>A  "<DEL><ESC>yyp0lv$hhr"yykPjj
autocmd FileType javascript,php,c map <leader>comm I//  <ESC>A  //<ESC>yyp0llv$hhhr-yykPjj
autocmd FileType python,ruby,sh,zsh map <leader>comm I#  <ESC>A  #<ESC>yyp0lv$hhr-yykPjj
autocmd FileType html,xhtml map <leader>comm I<!--  <DEL><ESC>A  --><ESC>yyp0llllv$r-$hhc$--><ESC>yykPjj
autocmd FileType css map <leader>comm I/*  <ESC>A  */<ESC>yyp0llv$r-$hc$*/<ESC>yykPjj

""""""""""""""""""""""""""""""
" => Visual mode related
""""""""""""""""""""""""""""""
" Really useful!
"  In visual mode when you press * or # to search for the current selection
vnoremap <silent> * :call VisualSearch('f')<CR>
vnoremap <silent> # :call VisualSearch('b')<CR>

" When you press gv you vimgrep after the selected text
vnoremap <silent> gv :call VisualSearch('gv')<CR>
map <leader>grp :vimgrep // **/*.<left><left><left><left><left><left><left>

function! CmdLine(str)
	exe "menu Foo.Bar :" . a:str
	emenu Foo.Bar
	unmenu Foo
endfunction

" From an idea by Michael Naumann
function! VisualSearch(direction) range
	let l:saved_reg = @"
	execute "normal! vgvy"

	let l:pattern = escape(@", '\\/.*$^~[]')
	let l:pattern = substitute(l:pattern, "\n$", "", "")

	if a:direction == 'b'
		execute "normal ?" . l:pattern . "^M"
	elseif a:direction == 'gv'
		call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.')
	elseif a:direction == 'f'
		execute "normal /" . l:pattern . "^M"
	endif

	let @/ = l:pattern
	let @" = l:saved_reg
endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Command mode related
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Move around matching bracket pairs
nnoremap <tab> %
vnoremap <tab> %

func! Cwd()
	let cwd = getcwd()
	return "e " . cwd
endfunc

func! DeleteTillSlash()
	let g:cmd = getcmdline()
	let g:cmd_edited = substitute(g:cmd, "\\(.*\[/\]\\).*", "\\1", "")
	if g:cmd == g:cmd_edited
		let g:cmd_edited = substitute(g:cmd, "\\(.*\[/\]\\).*/", "\\1", "")
	endif
	return g:cmd_edited
endfunc

func! CurrentFileDir(cmd)
	return a:cmd . " " . expand("%:p:h") . "/"
endfunc

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Moving around, tabs and buffers
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Remove the highlighted search
map <silent> <leader><cr> :noh<cr>

" Smart way to move btw. windows
map <C-j> <C-W>j
map <C-k> <C-W>k
map <C-h> <C-W>h
map <C-l> <C-W>l

" Close the current buffer
map <leader>bd :Bclose<cr>

" Close all the buffers
map <leader>ba :1,300 bd!<cr>

" Use the arrows to something usefull
map <right> :bn<cr>
map <left> :bp<cr>

" Tab configuration
map <leader>tb :tabnew<cr>
map <leader>te :tabedit
map <leader>tc :tabclose<cr>
map <leader>to :tabonly<cr>
map <leader>tn :tabnext<cr>
map <leader>tp :tabprevious<cr>
map <leader>tf :tabfirst<cr>
map <leader>tl :tablast<cr>
map <leader>tm :tabmove

" When pressing <leader>cd switch to the directory of the open buffer
map <leader>cd :cd %:p:h<cr>

command! Bclose call <SID>BufcloseCloseIt()
function! <SID>BufcloseCloseIt()
	let l:currentBufNum = bufnr("%")
	let l:alternateBufNum = bufnr("#")

	if buflisted(l:alternateBufNum)
		buffer #
	else
		bnext
	endif

	if bufnr("%") == l:currentBufNum
		new
	endif

	if buflisted(l:currentBufNum)
		execute("bdelete! ".l:currentBufNum)
	endif
endfunction

" Specify the behavior when switching between buffers
try
	set switchbuf=usetab
	set stal=2
catch
endtry

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => General Abbrevs
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
iab xdate <c-r>=strftime("%d/%m/%y %H:%M:%S")<cr>

iab #p #!/usr/bin/perl
iab #e #!/usr/bin/env
iab #r #!/usr/bin/ruby
iab #b #!/bin/bash

" For Web Design, Lorem Ipsum Dummy Text
iab lorem Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.

iab llorem Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Editing mappings
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Move a line of text using ALT+[jk] or Comamnd+[jk] on mac
nmap <M-j> mz:m+<cr>`z
nmap <M-k> mz:m-2<cr>`z
vmap <M-j> :m'>+<cr>`<my`>mzgv`yo`z
vmap <M-k> :m'<-2<cr>`>my`<mzgv`yo`z

" Indent visual selected code without unselecting and going back to normal mode
vmap > >gv
vmap < <gv

"Strip all trailing whitespace in the current file"
nnoremap <leader>nw :%s/\s\+$//e<cr>:let @/=''<CR>

"Delete trailing whitespace from vimcasts on Python, Javascript and Ruby"
function! DeleteTrailingWS()
	" Preparation: save the last search, and curson position"
	let _s=@/
	let l = line(".")
	let c = col(".")
	" Do the business"
	%s/\s\+$//e
	"Clean up: restore previous search history and cursor position"
	let @/=_s
	call cursor(l, c)
endfunction

" Delete trailing space when saving Python, Ruby and Javascript files"
autocmd BufWrite *.py,*.js,*.rb :call DeleteTrailingWS()

"CTRL-X is cut
vnoremap <C-X> "+x

"CTRL-C is copy
vnoremap <C-C> "+y

" Smart Paste CTRL-V from the system's clipboard and indents code automatically
nnoremap <C-V> "+P=']
inoremap <C-V> <C-o>"+P<C-o>=']
"
" Pasting blockwise and linewise selections is not possible in Insert and
" Visual mode without the +virtualedit feature.  They are pasted as if they
" were characterwise instead.
" Uses the paste.vim autoload script.

exe 'inoremap <script> <C-V>' paste#paste_cmd['i']
exe 'vnoremap <script> <C-V>' paste#paste_cmd['v']

imap <S-Insert> <C-V>
vmap <S-Insert> <C-V>

" Use CTRL-Q to do what CTRL-V used to do, Blockwise Visual Selection
noremap <C-Q>   <C-V>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Documentation writing and Formatting
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
map <leader>h1 yypVr=o
map <leader>h2 yypVr-o

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Cope
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Do :help cope if you are unsure what cope is. It's super useful!
map <leader>cope :botright cope<cr>
map <leader>n :cn<cr>
map <leader>p :cp<cr>

""""""""""""""""""""""""""""""
" => NeoComplCache plugin
""""""""""""""""""""""""""""""

" TODO: Still need to tweak behavior with <TAB> to expand
"       snippets, change throughout the autocompletion list

" Use neocomplcache.
let g:neocomplcache_enable_at_startup = 1

" Use smartcase.
let g:neocomplcache_enable_smart_case = 1

" Use camel case completion.
let g:neocomplcache_enable_camel_case_completion = 1

" Use underbar completion.
let g:neocomplcache_enable_underbar_completion = 1

let g:neocomplcache_auto_completion_start_length = 3
let g:neocomplcache_manual_completion_start_length = 3
let g:neocomplcache_lock_buffer_name_pattern = '\*ku\*'

" Define keyword.
if !exists('g:neocomplcache_keyword_patterns')
	let g:neocomplcache_keyword_patterns = {}
endif
let g:neocomplcache_keyword_patterns['default'] = '\h\w*'


" Recommended key-mappings. 
" <CR>: close popup and save indent. 
"inoremap <expr><CR>  neocomplcache#smart_close_popup() . "\<CR>" 
"" <TAB>: completion. 
"inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>" 
"" <C-h>, <BS>: close popup and delete backword char. 
"inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>" 
"inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>" 
"inoremap <expr><C-y>  neocomplcache#close_popup() 
"inoremap <expr><C-e>  neocomplcache#cancel_popup() 

" AutoComplPop like behavior. 
"let g:neocomplcache_enable_auto_select = 1

" snippets expand key
"imap  <silent><expr><TAB>  neocomplcache#plugin#snippets_complete#expandable() ? "\<Plug>(neocomplcache_snippets_expand)" : (pumvisible() ? "\<C-e>" : "\<TAB>")
"imap  <silent><expr><TAB>  neocomplcache#plugin#snippets_complete#expandable() ? "\<Plug>(neocomplcache_snippets_expand)" : "\<C-e>"
"smap  <TAB>  <RIGHT><Plug>(neocomplcache_snippets_jump)
"inoremap <expr><C-e>     neocomplcache#complete_common_string()

" Enable omni completion. 
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS 
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags 
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS 
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete 
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags 

" Enable heavy omni completion. 
if !exists('g:neocomplcache_omni_patterns') 
	let g:neocomplcache_omni_patterns = {} 
endif 
let g:neocomplcache_omni_patterns.ruby = '[^. *\t]\.\w*\|\h\w*::' 
"autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete 
let g:neocomplcache_omni_patterns.php = '[^. \t]->\h\w*\|\h\w*::'

au BufNewFile,BufRead *.snip set syntax=snippet ft=snippet foldmethod=indent

""""""""""""""""""""""""""""""
" => Autoclose plugin
""""""""""""""""""""""""""""""
nmap <Leader>tac <Plug>ToggleAutoCloseMappings

""""""""""""""""""""""""""""""
" => Minibuffer plugin
""""""""""""""""""""""""""""""
let g:miniBufExplModSelTarget = 1
let g:miniBufExplorerMoreThanOne = 2
let g:miniBufExplModSelTarget = 0
let g:miniBufExplUseSingleClick = 1
let g:miniBufExplMapWindowNavVim = 1
let g:miniBufExplVSplit = 25
let g:miniBufExplSplitBelow=1

let g:bufExplorerSortBy = "name"

autocmd BufRead,BufNew :call UMiniBufExplorer

map <leader>u :TMiniBufExplorer<cr>

""""""""""""""""""""""""""""""
" => Gundo plugin
""""""""""""""""""""""""""""""
nnoremap <leader>gun :GundoToggle<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Web Development formatting
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" for CSS, also have things in braces indented:
autocmd FileType css set smartindent foldmethod=indent

" for HTML, generally format text, but if a long line has been created
" leave it alone when editing:
autocmd FileType html,xhtml set formatoptions+=tl

" folding HTML
autocmd FileType html,xhtml set foldmethod=indent smartindent

" for both CSS and HTML, use genuine tab characters for
" indentation, to make files a few bytes smaller:
autocmd FileType html,xhtml set noexpandtab tabstop=3 shiftwidth=3
autocmd FileType css set noexpandtab tabstop=2 shiftwidth=2

" Color picker for CSS
if has("mac")
	map <leader>pik :PickHEX<CR>
else
	map <leader>pik <Esc>:ColorPicker<Cr>a
	vmap <leader>pik <Del><Esc>h:ColorPicker<Cr>a
endif

" Sort CSS properties
nnoremap <leader>sort ?{<CR>jV/^\s*\}?$<CR>k:sort<CR>:noh<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Spell checking
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Pressing ,ss will toggle and untoggle spell checking
map <leader>spell :setlocal spell!<cr>

" languages for the spelling checker
set spelllang=en,es

"Shortcuts using <leader>
map <leader>sn ]s
map <leader>sp [s
map <leader>sa zg
map <leader>s? z=

""""""""""""""""""""""""""""""
" => Ruby section
""""""""""""""""""""""""""""""
au FileType ruby setlocal ts=2 sts=2 sw=2 noexpandtab foldmethod=syntax

""""""""""""""""""""""""""""""
" => Python section
""""""""""""""""""""""""""""""
au FileType python set nocindent
let python_highlight_all = 1
au FileType python syn keyword pythonDecorator True None False self

au BufNewFile,BufRead *.jinja set syntax=htmljinja
au BufNewFile,BufRead *.mako set ft=mako

au FileType python inoremap <buffer> $r return
au FileType python inoremap <buffer> $i import
au FileType python inoremap <buffer> $p print
au FileType python inoremap <buffer> $f #--- PH ----------------------------------------------<esc>FP2xi
au FileType python map <buffer> <leader>1 /class
au FileType python map <buffer> <leader>2 /def
au FileType python map <buffer> <leader>C ?class
au FileType python map <buffer> <leader>D ?def

""""""""""""""""""""""
"  Markdown Section  "
""""""""""""""""""""""
au FileType markdown set linespace=5 ai formatoptions=tcroqn2 comments=n:&gt;

" Preview Markdown text
au Filetype markdown nmap <leader>pv : call MarkdownPreview()<CR>
func! MarkdownPreview()
	if has("mac")
		exec "!markdown % > /tmp/previewmkd.html && open /tmp/previewmkd.html"
	else
		exec "!markdown % > /tmp/previewmkd.html && firefox /tmp/previewmkd.html"
	endif
endfunc

""""""""""""""""""""""""""""""
" => JavaScript section
"""""""""""""""""""""""""""""""
au FileType javascript setlocal ts=4 sts=4 sw=4 noexpandtab
au FileType javascript call JavaScriptFold()
au FileType javascript setl fen
au FileType javascript setl nocindent

au FileType javascript imap <c-t> AJS.log();<esc>hi
au FileType javascript imap <c-a> alert();<esc>hi

au FileType javascript inoremap <buffer> $r return
au FileType javascript inoremap <buffer> $f //--- PH ----------------------------------------------<esc>FP2xi

" Javascript Lint for the inline scripts in HTML files
au BufWritePost,FileWritePost *.js,*.html call JavascriptLint()

" jQuery syntax
au BufRead,BufNewFile jquery.*.js set ft=javascript syntax=jquery

function! JavaScriptFold()
	setl foldmethod=syntax
	setl foldlevelstart=1
	syn region foldBraces start=/{/ end=/}/ transparent fold keepend extend

	function! FoldText()
		return substitute(getline(v:foldstart), '{.*', '{...}', '')
	endfunction
	setl foldtext=FoldText()
endfunction

" Javascript Lint integrated to Vim
au FileType javascript map <leader>jsl : call JavaScriptLint()<CR>
func! JavaScriptLint()
	exec "w"
	exec "!jsl -conf ~/.vim/jsl.conf -process % "
endfunc

"""""""""""""""""""""""""""""""
" => HTML section
"""""""""""""""""""""""""""""""
au FileType html,xhtml,xml so ~/.vim/ftplugin/html_autoclosetag.vim

" HTML Tidy
au FileType html,xhtml setlocal makeprg=tidy\ -config\ $HOME/.vim/tidy.conf\ -quiet\ -errors\ %
au FileType html,xhtml setlocal errorformat=line\ %l\ column\ %v\ -\ %m

" Load the current buffer in Default Web Browser or Firefox
au Filetype html,xhtml nmap <leader>pv : call PreviewInBrowser()<CR>
func! PreviewInBrowser()
	if has("mac")
		exec "!open %"
		"exec "!open -a firefox.app %:p"
	else
		exec "!firefox %"
	endif
endfunc

""""""""""""""""""""""""""""""
" => Taglist
""""""""""""""""""""""""""""""
" TagList options
let Tlist_Close_On_Select = 1 "close taglist window once we selected something
let Tlist_Exit_OnlyWindow = 1 "if taglist window is the only window left, exit vim
let Tlist_Show_Menu = 1 "show Tags menu in gvim
let Tlist_Show_One_File = 1 "show tags of only one file
let Tlist_GainFocus_On_ToggleOpen = 1 "automatically switch to taglist window
let Tlist_Highlight_Tag_On_BufEnter = 1 "highlight current tag in taglist window
let Tlist_Process_File_Always = 1 "taglist window on the right
let Tlist_Display_Prototype = 1 "display full prototype instead of just function name
" "let Tlist_Ctags_Cmd = /usr/local/bin/ctags

nnoremap <F5> :TlistToggle<CR>
nnoremap <F6> :TlistShowPrototype<CR>

""""""""""""""""""""""""""""""
" => NerdTree
""""""""""""""""""""""""""""""
map <leader>3 NERDTreeToggle<CR>

""""""""""""""""""""""""""""""
" => SuperTab
""""""""""""""""""""""""""""""
let g:SuperTabCompletionContexts = ['s:ContextText', 's:ContextDiscover']
let g:SuperTabContextTextOmniPrecedence = ['&omnifunc', '&completefunc']
let g:SuperTabContextDiscoverDiscovery = ["&completefunc:<c-x><c-u>", "&omnifunc:<c-x><c-o>"]

""""""""""""""""""""""""""""""
" => Vim grep and Ack
""""""""""""""""""""""""""""""
" Using Ack instead of grep.
set grepprg=ack

nnoremap <leader>a :Ack

""""""""""""""""""""""""""""""
" => Statusline
""""""""""""""""""""""""""""""
" Always hide the statusline
set laststatus=2
"" jamessan's
"set statusline=   " clear the statusline for when vimrc is reloaded
"set statusline+=%-3.3n\                      " buffer number
"set statusline+=%f\                          " file name
"set statusline+=%h%m%r%w                     " flags
"set statusline+=[%{strlen(&ft)?&ft:'none'},  " filetype
"set statusline+=%{strlen(&fenc)?&fenc:&enc}, " encoding
"set statusline+=%{&fileformat}]              " file format
"set statusline+=%=                           " right align
"set statusline+=%{synIDattr(synID(line('.'),col('.'),1),'name')}\  " highlight
"set statusline+=%b,0x%-8B\                   " current char
"set statusline+=%-14.(%l,%c%V%)\ %<%P        " offset

" Format the statusline

"set statusline=%<\%F%m%r%h%w\ [%{FileSize()}]\ %y\ [%{&ff}]\ \
"\[%{strlen(&fenc)?&fenc:'none'}]\ \
"\%{exists('g:loaded_fugitive')?fugitive#statusline():''}\ \
"\%{exists('g:loaded_rvm')?rvm#statusline_ft_ruby():''}\ \
"\%{&filetype=='perl'?'['.system($perlv).']':''}\ \
"\[r%{HGRev()}]\ \
"\[%{Tlist_Get_Tagname_By_Line()}]
"\%{exists('*CapsLockStatusline')?CapsLockStatusline():''}
"\%=%l,%c%V\ \ %L\ lines:%p\

"let g:ctags_statusline=1
" }}}

source $HOME/.vim/functions
" {{{ Nice statusbar
"statusline setup

set statusline=   " clear the statusline for when vimrc is reloaded
set statusline+=%-2.2n\                      " buffer number
set statusline+=%f\       "tail of the filename

"display a warning if fileformat isnt unix
set statusline+=%#warningmsg#
set statusline+=%{&ff!='unix'?'['.&ff.']':''}
set statusline+=%*

"display a warning if file encoding isnt utf-8
set statusline+=%#warningmsg#
set statusline+=%{(&fenc!='utf-8'&&&fenc!='')?'['.&fenc.']':''}
set statusline+=%*

set statusline+=%h      "help file flag
set statusline+=%y\      "filetype
set statusline+=%r      "read only flag
set statusline+=%m\      "modified flag

" display the filesize
set statusline+=[%{FileSize()}]\ 

" display current git branch
set statusline+=%{fugitive#statusline()}\ 

"display a warning if &et is wrong, or we have mixed-indenting
set statusline+=%#error#
set statusline+=%{StatuslineTabWarning()}
set statusline+=%*

set statusline+=%{StatuslineTrailingSpaceWarning()}

set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

"display a warning if &paste is set
set statusline+=%#error#
set statusline+=%{&paste?'[paste]':''}
set statusline+=%*

set statusline+=%=      "left/right separator
set statusline+=[%{Tlist_Get_Tagname_By_Line()}]\ 
set statusline+=%{StatuslineCurrentHighlight()}\ \ "current highlight
set statusline+=%c,     "cursor column
set statusline+=%l/%L   "cursor line/total lines
set statusline+=\ %P\   "percent through file
set laststatus=2        " Always show status line

" }}}

" {{{ Window title
if has('title') && (has('gui_running') || &title)
	set titlestring=
	set titlestring+=%f\                                              " file name
	set titlestring+=%h%m%r%w                                         " flags
	set titlestring+=\ -\ %{v:progname}                               " program name
	set titlestring+=\ -\ %{substitute(getcwd(),\ $HOME,\ '~',\ '')}  " working directory
endif

"highlight the current line
"if v:version > 700
"    set cursorline
"    hi Cursorline ctermbg=Red guibg=#771c1c
"else
"    syntax match CurrentLine /.*\%#.*/
"    hi CurrentLine guifg=white guibg=lightblue
"endif

" If we have a BOM, always honour that rather than trying to guess.
if &fileencodings !~? "ucs-bom"
	set fileencodings^=ucs-bom
endif

" Always check for UTF-8 when trying to determine encodings.
if &fileencodings !~? "utf-8"
	" If we have to add this, the default encoding is not Unicode.
	" We use this fact later to revert to the default encoding in plaintext/empty
	" files.
	let g:added_fenc_utf8 = 1
	set fileencodings+=utf-8
endif

" Make sure we have a sane fallback for encoding detection
if &fileencodings !~? "default"
	set fileencodings+=default
endif
function! CurDir()
	let curdir = substitute(getcwd(), '/Users/jose/', "~/", "g")
	return curdir
endfunction

function! FileSize()
	let bytes = getfsize(expand("%:p"))
	if bytes <= 0
		return ""
	endif
	if bytes < 1024
		return bytes . " Bytes"
	else
		return (bytes / 1024) . "kB"
	endif
endfunction

